"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZipWriter = void 0;
const stream_1 = require("stream");
const JSZip = require("jszip");
const logger_1 = require("../logger/logger");
const sfError_1 = require("../sfError");
class ZipWriter extends stream_1.Writable {
    constructor(rootDestination) {
        super({ objectMode: true });
        this.rootDestination = rootDestination;
        this.zip = JSZip();
        const destination = rootDestination ? `for: ${rootDestination}` : 'in memory';
        this.logger = logger_1.Logger.childFromRoot(this.constructor.name);
        this.logger.debug(`generating zip ${destination}`);
    }
    get buffer() {
        if (!this.zipBuffer) {
            throw new sfError_1.SfError('Must finalize the ZipWriter before getting a buffer');
        }
        return this.zipBuffer;
    }
    async addToStore(contents, path) {
        // Ensure only posix paths are added to zip files
        const posixPath = path.replace(/\\/g, '/');
        this.zip.file(posixPath, contents);
        return Promise.resolve();
    }
    async finalize() {
        // compression-/speed+ (0)<---(3)---------->(9) compression+/speed-
        // 3 appears to be a decent balance of compression and speed. It felt like
        // higher values = diminishing returns on compression and made conversion slower
        this.zipBuffer = await this.zip.generateAsync({
            type: 'nodebuffer',
            compression: 'DEFLATE',
            compressionOptions: { level: 3 },
        });
        this.logger.debug('Generated zip complete');
    }
    getDestinationPath() {
        return this.rootDestination;
    }
}
exports.ZipWriter = ZipWriter;
//# sourceMappingURL=zipWriter.js.map