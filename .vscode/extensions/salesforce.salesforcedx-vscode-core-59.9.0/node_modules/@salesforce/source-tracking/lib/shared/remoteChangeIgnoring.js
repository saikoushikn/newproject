"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.remoteChangeToMetadataMember = exports.removeIgnored = exports.changeResultToMetadataComponent = void 0;
/*
 * Copyright (c) 2023, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const core_1 = require("@salesforce/core");
const filePathGenerator_1 = require("@salesforce/source-deploy-retrieve/lib/src/utils/filePathGenerator");
const changeResultToMetadataComponent = (cr, registry = new source_deploy_retrieve_1.RegistryAccess()) => {
    if (!cr.name || !cr.type) {
        throw new core_1.SfError(`Change Result is missing name or type: ${JSON.stringify(cr)}`);
    }
    return {
        fullName: cr.name,
        type: registry.getTypeByName(cr.type),
    };
};
exports.changeResultToMetadataComponent = changeResultToMetadataComponent;
const removeIgnored = (changeResults, forceIgnore, defaultPkgDir) => {
    const registry = new source_deploy_retrieve_1.RegistryAccess();
    return changeResults
        .map((cr) => (0, exports.changeResultToMetadataComponent)(cr, registry))
        .filter((mc) => !(0, filePathGenerator_1.filePathsFromMetadataComponent)(mc, defaultPkgDir).some((f) => forceIgnore.denies(f)))
        .map((mc) => ({ type: mc.type.name, fullName: mc.fullName }));
};
exports.removeIgnored = removeIgnored;
const remoteChangeToMetadataMember = (cr) => {
    if (!cr.name || !cr.type) {
        throw new core_1.SfError(`Change Result is missing name or type: ${JSON.stringify(cr)}`);
    }
    return {
        fullName: cr.name,
        type: cr.type,
    };
};
exports.remoteChangeToMetadataMember = remoteChangeToMetadataMember;
//# sourceMappingURL=remoteChangeIgnoring.js.map