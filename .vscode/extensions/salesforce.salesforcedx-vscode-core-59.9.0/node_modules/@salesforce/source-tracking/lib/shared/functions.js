"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.deleteCustomLabels = exports.ensureRelative = exports.chunkArray = exports.pathIsInFolder = exports.isLwcLocalOnlyTest = exports.supportsPartialDelete = exports.getKeyFromObject = exports.getMetadataKey = void 0;
const node_path_1 = require("node:path");
const fs = require("node:fs");
const ts_types_1 = require("@salesforce/ts-types");
const fast_xml_parser_1 = require("fast-xml-parser");
const kit_1 = require("@salesforce/kit");
const getMetadataKey = (metadataType, metadataName) => `${metadataType}__${metadataName}`;
exports.getMetadataKey = getMetadataKey;
const getKeyFromObject = (element) => {
    if (element.type && element.name) {
        return (0, exports.getMetadataKey)(element.type, element.name);
    }
    throw new Error(`unable to complete key from ${JSON.stringify(element)}`);
};
exports.getKeyFromObject = getKeyFromObject;
const supportsPartialDelete = (cmp) => !!cmp.type.supportsPartialDelete;
exports.supportsPartialDelete = supportsPartialDelete;
const isLwcLocalOnlyTest = (filePath) => filePath.includes('__utam__') || filePath.includes('__tests__');
exports.isLwcLocalOnlyTest = isLwcLocalOnlyTest;
/**
 * Verify that a filepath starts exactly with a complete parent path
 * ex: '/foo/bar-extra/baz'.startsWith('foo/bar') would be true, but this function understands that they are not in the same folder
 */
const pathIsInFolder = (filePath, folder) => {
    const biggerStringParts = (0, node_path_1.normalize)(filePath).split(node_path_1.sep).filter(nonEmptyStringFilter);
    return (0, node_path_1.normalize)(folder)
        .split(node_path_1.sep)
        .filter(nonEmptyStringFilter)
        .every((part, index) => part === biggerStringParts[index]);
};
exports.pathIsInFolder = pathIsInFolder;
const nonEmptyStringFilter = (value) => (0, ts_types_1.isString)(value) && value.length > 0;
// adapted for TS from https://github.com/30-seconds/30-seconds-of-code/blob/master/snippets/chunk.md
const chunkArray = (arr, size) => Array.from({ length: Math.ceil(arr.length / size) }, (v, i) => arr.slice(i * size, i * size + size));
exports.chunkArray = chunkArray;
const ensureRelative = (filePath, projectPath) => (0, node_path_1.isAbsolute)(filePath) ? (0, node_path_1.relative)(projectPath, filePath) : filePath;
exports.ensureRelative = ensureRelative;
/**
 * A method to help delete custom labels from a file, or the entire file if there are no more labels
 *
 * @param filename - a path to a custom labels file
 * @param customLabels - an array of SourceComponents representing the custom labels to delete
 * @returns -json equivalent of the custom labels file's contents OR undefined if the file was deleted/not written
 */
const deleteCustomLabels = async (filename, customLabels) => {
    const customLabelsToDelete = customLabels
        .filter((label) => label.type.id === 'customlabel')
        .map((change) => change.fullName);
    // if we don't have custom labels, we don't need to do anything
    if (!customLabelsToDelete.length) {
        return undefined;
    }
    // for custom labels, we need to remove the individual label from the xml file
    // so we'll parse the xml
    const parser = new fast_xml_parser_1.XMLParser({
        ignoreDeclaration: false,
        ignoreAttributes: false,
        attributeNamePrefix: '@_',
    });
    const cls = parser.parse(fs.readFileSync(filename, 'utf8'));
    // delete the labels from the json based on their fullName's
    cls.CustomLabels.labels = (0, kit_1.ensureArray)(cls.CustomLabels.labels).filter((label) => !customLabelsToDelete.includes(label.fullName));
    if (cls.CustomLabels.labels.length === 0) {
        // we've deleted everything, so let's delete the file
        await fs.promises.unlink(filename);
        return undefined;
    }
    else {
        // we need to write the file json back to xml back to the fs
        const builder = new fast_xml_parser_1.XMLBuilder({
            attributeNamePrefix: '@_',
            ignoreAttributes: false,
            format: true,
            indentBy: '    ',
        });
        // and then write that json back to xml and back to the fs
        const xml = builder.build(cls);
        await fs.promises.writeFile(filename, xml);
        return cls;
    }
};
exports.deleteCustomLabels = deleteCustomLabels;
//# sourceMappingURL=functions.js.map