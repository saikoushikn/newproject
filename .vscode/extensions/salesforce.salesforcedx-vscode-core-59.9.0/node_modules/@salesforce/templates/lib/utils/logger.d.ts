export declare class Log {
    private output;
    private cleanOutput;
    [index: string]: any;
    constructor();
    getOutput(): string;
    getCleanOutput(): string[];
    write(...args: [string]): Log;
    pad(status: string): string;
    setOutput(text: string): void;
    setCleanOutput(cleanText: string[]): void;
    clear(): void;
}
export interface ILogRef {
    (args: string): void;
    clear(): void;
    setCleanOutput(...args: string[]): void;
    setOutput(text: string): void;
    pad(status: string): string;
    write(arg: string): ILogRef;
    getCleanOutput(): string[];
    getOutput(): string;
    skip(arg: string): ILogRef;
    force(arg: string): ILogRef;
    create(arg: string): ILogRef;
    invoke(arg: string): ILogRef;
    conflict(arg: string): ILogRef;
    identical(arg: string): ILogRef;
    info(arg: string): ILogRef;
}
/**
 * The Yeoman adapter had a log property that has the unusual
 * requirement of being both a function and an object. See the yeoman
 * environment log implementation
 * https://github.com/yeoman/environment/blob/5f0e87b696c4926ba69b9fbd83e4486a02492fcc/lib/util/log.js#L59
 *
 * @param log The Log instance for the Yeoman logger to utilize.
 * @returns The log instance that is both a function and an object.
 */
export declare const getYeomanLogger: (log: Log) => ILogRef;
