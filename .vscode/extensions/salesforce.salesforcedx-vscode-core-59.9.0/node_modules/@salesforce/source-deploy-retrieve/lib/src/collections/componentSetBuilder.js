"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComponentSetBuilder = void 0;
/* eslint complexity: ["error", 22] */
const path = require("node:path");
const core_1 = require("@salesforce/core");
const fs = require("graceful-fs");
const collections_1 = require("../collections");
const registry_1 = require("../registry");
const messages = new core_1.Messages('@salesforce/source-deploy-retrieve', 'sdr', new Map([["md_request_fail", "Metadata API request failed: %s"], ["error_convert_invalid_format", "Invalid conversion format '%s'"], ["error_could_not_infer_type", "%s: Could not infer a metadata type"], ["error_unexpected_child_type", "Unexpected child metadata [%s] found for parent type [%s]"], ["noParent", "Could not find parent type for %s (%s)"], ["error_expected_source_files", "%s: Expected source files for type '%s'"], ["error_failed_convert", "Component conversion failed: %s"], ["error_merge_metadata_target_unsupported", "Merge convert for metadata target format currently unsupported"], ["error_missing_adapter", "Missing adapter '%s' for metadata type '%s'"], ["error_missing_transformer", "Missing transformer '%s' for metadata type '%s'"], ["error_missing_type_definition", "Missing metadata type definition in registry for id '%s'."], ["error_missing_child_type_definition", "Type %s does not have a child type definition %s."], ["noChildTypes", "No child types found in registry for %s (reading %s at %s)"], ["error_no_metadata_xml_ignore", "Metadata xml file %s is forceignored but is required for %s."], ["noSourceIgnore", "%s metadata types require source files, but %s is forceignored."], ["noSourceIgnore.actions", "- Metadata types with content are composed of two files: a content file (ie MyApexClass.cls) and a -meta.xml file (i.e MyApexClass.cls-meta.xml). You must include both files in your .forceignore file. Or try appending \u201C\\*\u201D to your existing .forceignore entry.\n\nSee <https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_exclude_source.htm> for examples"], ["error_path_not_found", "%s: File or folder not found"], ["noContentFound", "SourceComponent %s (metadata type = %s) is missing its content file."], ["noContentFound.actions", ["Ensure the content file exists in the expected location.", "If the content file is in your .forceignore file, ensure the meta-xml file is also ignored to completely exclude it."]], ["error_parsing_xml", "SourceComponent %s (metadata type = %s) does not have an associated metadata xml to parse"], ["error_expected_file_path", "%s: path is to a directory, expected a file"], ["error_expected_directory_path", "%s: path is to a file, expected a directory"], ["error_directory_not_found_or_not_directory", "%s: path is not a directory"], ["error_no_directory_stream", "%s doesn't support readable streams on directories."], ["error_no_source_to_deploy", "No source-backed components present in the package."], ["error_no_components_to_retrieve", "No components in the package to retrieve."], ["error_static_resource_expected_archive_type", "A StaticResource directory must have a content type of application/zip or application/jar - found %s for %s."], ["error_static_resource_missing_resource_file", "A StaticResource must have an associated .resource file, missing %s.resource-meta.xml"], ["error_no_job_id", "The %s operation is missing a job ID. Initialize an operation with an ID, or start a new job."], ["invalid_xml_parsing", "error parsing %s due to:\\n message: %s\\n line: %s\\n code: %s"], ["zipBufferError", "Zip buffer was not created during conversion"], ["undefinedComponentSet", "Unable to construct a componentSet. Check the logs for more information."], ["replacementsFileNotRead", "The file \"%s\" specified in the \"replacements\" property of sfdx-project.json could not be read."], ["unsupportedBundleType", "Unsupported Bundle Type: %s"], ["filePathGeneratorNoTypeSupport", "Type not supported for filepath generation: %s"], ["missingFolderType", "The registry has %s as is inFolder but it does not have a folderType"], ["tooManyFiles", "Multiple files found for path: %s."], ["cantGetName", "Unable to calculate fullName from path: %s (%s)"], ["missingMetaFileSuffix", "The metadata registry is configured incorrectly for %s. Expected a metaFileSuffix."], ["uniqueIdElementNotInRegistry", "No uniqueIdElement found in registry for %s (reading %s at %s)."], ["uniqueIdElementNotInChild", "The uniqueIdElement %s was not found the child (reading %s at %s)."], ["suggest_type_header", "A metadata type lookup for \"%s\" found the following close matches:"], ["suggest_type_did_you_mean", "-- Did you mean \".%s%s\" instead for the \"%s\" metadata type?"], ["suggest_type_more_suggestions", "Additional suggestions:\nConfirm the file name, extension, and directory names are correct. Validate against the registry at:\n<https://github.com/forcedotcom/source-deploy-retrieve/blob/main/src/registry/metadataRegistry.json>\n\nIf the type is not listed in the registry, check that it has Metadata API support via the Metadata Coverage Report:\n<https://developer.salesforce.com/docs/metadata-coverage>\n\nIf the type is available via Metadata API but not in the registry\n\n- Open an issue <https://github.com/forcedotcom/cli/issues>\n- Add the type via PR. Instructions: <https://github.com/forcedotcom/source-deploy-retrieve/blob/main/contributing/metadata.md>"]]));
class ComponentSetBuilder {
    /**
     * Builds a ComponentSet that can be used for source conversion,
     * deployment, or retrieval, using all specified options.
     *
     * @see https://github.com/forcedotcom/source-deploy-retrieve/blob/develop/src/collections/componentSet.ts
     *
     * @param options: options for creating a ComponentSet
     */
    // eslint-disable-next-line complexity
    static async build(options) {
        const logger = core_1.Logger.childFromRoot('componentSetBuilder');
        let componentSet;
        const { sourcepath, manifest, metadata, packagenames, apiversion, sourceapiversion, org } = options;
        try {
            if (sourcepath) {
                logger.debug(`Building ComponentSet from sourcepath: ${sourcepath.join(', ')}`);
                const fsPaths = sourcepath.map((filepath) => {
                    if (!fs.existsSync(filepath)) {
                        throw new core_1.SfError(messages.getMessage('error_path_not_found', [filepath]));
                    }
                    return path.resolve(filepath);
                });
                componentSet = collections_1.ComponentSet.fromSource({ fsPaths });
            }
            // Return empty ComponentSet and use packageNames in the connection via `.retrieve` options
            if (packagenames) {
                logger.debug(`Building ComponentSet for packagenames: ${packagenames.toString()}`);
                componentSet ??= new collections_1.ComponentSet();
            }
            // Resolve manifest with source in package directories.
            if (manifest) {
                logger.debug(`Building ComponentSet from manifest: ${manifest.manifestPath}`);
                if (!fs.existsSync(manifest.manifestPath)) {
                    throw new core_1.SfError(messages.getMessage('error_path_not_found', [manifest.manifestPath]));
                }
                const directoryPaths = manifest.directoryPaths;
                logger.debug(`Searching in packageDir: ${directoryPaths.join(', ')} for matching metadata`);
                componentSet = await collections_1.ComponentSet.fromManifest({
                    manifestPath: manifest.manifestPath,
                    resolveSourcePaths: directoryPaths,
                    forceAddWildcards: true,
                    destructivePre: manifest.destructiveChangesPre,
                    destructivePost: manifest.destructiveChangesPost,
                });
            }
            // Resolve metadata entries with source in package directories.
            if (metadata) {
                logger.debug(`Building ComponentSet from metadata: ${metadata.metadataEntries.toString()}`);
                const registry = new registry_1.RegistryAccess();
                const compSetFilter = new collections_1.ComponentSet();
                componentSet ??= new collections_1.ComponentSet();
                const directoryPaths = metadata.directoryPaths;
                // Build a Set of metadata entries
                metadata.metadataEntries.forEach((rawEntry) => {
                    const splitEntry = rawEntry.split(':').map((entry) => entry.trim());
                    // The registry will throw if it doesn't know what this type is.
                    registry.getTypeByName(splitEntry[0]);
                    // this '.*' is a surprisingly valid way to specify a metadata, especially a DEB :sigh:
                    // https://github.com/salesforcecli/plugin-deploy-retrieve/blob/main/test/nuts/digitalExperienceBundle/constants.ts#L140
                    // because we're filtering from what we have locally, this won't allow you to retrieve new metadata (on the server only) using the partial wildcard
                    // to do that, you'd need check the size of the CS created below, see if it's 0, and then query the org for the metadata that matches the regex
                    // but building a CS from a metadata argument doesn't require an org, so we can't do that here
                    if (splitEntry[1]?.includes('*') && splitEntry[1]?.length > 1 && !splitEntry[1].includes('.*')) {
                        // get all components of the type, and then filter by the regex of the fullName
                        collections_1.ComponentSet.fromSource({
                            fsPaths: directoryPaths,
                            include: new collections_1.ComponentSet([{ type: splitEntry[0], fullName: collections_1.ComponentSet.WILDCARD }]),
                        })
                            .getSourceComponents()
                            .toArray()
                            .filter((cs) => Boolean(cs.fullName.match(new RegExp(splitEntry[1]))))
                            .map((match) => {
                            compSetFilter.add(match);
                            componentSet?.add(match);
                        });
                    }
                    else {
                        const entry = {
                            type: splitEntry[0],
                            fullName: splitEntry.length === 1 ? '*' : splitEntry[1],
                        };
                        // Add to the filtered ComponentSet for resolved source paths,
                        // and the unfiltered ComponentSet to build the correct manifest.
                        compSetFilter.add(entry);
                        componentSet?.add(entry);
                    }
                });
                logger.debug(`Searching for matching metadata in directories: ${directoryPaths.join(', ')}`);
                const resolvedComponents = collections_1.ComponentSet.fromSource({ fsPaths: directoryPaths, include: compSetFilter });
                componentSet.forceIgnoredPaths = resolvedComponents.forceIgnoredPaths;
                for (const comp of resolvedComponents) {
                    componentSet.add(comp);
                }
            }
            // Resolve metadata entries with an org connection
            if (org) {
                componentSet ??= new collections_1.ComponentSet();
                logger.debug(`Building ComponentSet from targetUsername: ${org.username}`);
                const fromConnection = await collections_1.ComponentSet.fromConnection({
                    usernameOrConnection: (await core_1.StateAggregator.getInstance()).aliases.getUsername(org.username) ?? org.username,
                    // exclude components based on the results of componentFilter function
                    // components with namespacePrefix where org.exclude includes manageableState (to exclude managed packages)
                    // components with namespacePrefix where manageableState equals undefined (to exclude components e.g. InstalledPackage)
                    // components where org.exclude includes manageableState (to exclude packages without namespacePrefix e.g. unlocked packages)
                    componentFilter: (component) => !component?.manageableState || !org.exclude?.includes(component.manageableState),
                });
                for (const comp of fromConnection) {
                    componentSet.add(comp);
                }
            }
        }
        catch (e) {
            if (e.message.includes('Missing metadata type definition in registry for id')) {
                // to remain generic to catch missing metadata types regardless of parameters, split on '
                // example message : Missing metadata type definition in registry for id 'NonExistentType'
                const issueType = e.message.split("'")[1];
                throw new core_1.SfError(`The specified metadata type is unsupported: [${issueType}]`);
            }
            else {
                throw e;
            }
        }
        // This is only for debug output of matched files based on the command flags.
        // It will log up to 20 file matches.
        if (logger.shouldLog(20) && componentSet?.size) {
            logger.debug(`Matching metadata files (${componentSet.size}):`);
            const components = componentSet.getSourceComponents().toArray();
            for (let i = 0; i < componentSet.size; i++) {
                if (components[i]?.content) {
                    logger.debug(components[i].content);
                }
                else if (components[i]?.xml) {
                    logger.debug(components[i].xml);
                }
                if (i > 18) {
                    logger.debug(`(showing 20 of ${componentSet.size} matches)`);
                    break;
                }
            }
        }
        // there should have been a componentSet created by this point.
        if (componentSet === undefined) {
            throw new core_1.SfError('undefinedComponentSet');
        }
        componentSet.apiVersion ??= apiversion;
        componentSet.sourceApiVersion ??= sourceapiversion;
        logger.debug(`ComponentSet apiVersion = ${componentSet.apiVersion}`);
        logger.debug(`ComponentSet sourceApiVersion = ${componentSet.sourceApiVersion}`);
        return componentSet;
    }
}
exports.ComponentSetBuilder = ComponentSetBuilder;
//# sourceMappingURL=componentSetBuilder.js.map