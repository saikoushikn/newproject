"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataResolver = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const node_path_1 = require("node:path");
const core_1 = require("@salesforce/core");
const utils_1 = require("../utils");
const registry_1 = require("../registry");
const common_1 = require("../common");
const sourceAdapterFactory_1 = require("./adapters/sourceAdapterFactory");
const forceIgnore_1 = require("./forceIgnore");
const treeContainers_1 = require("./treeContainers");
const messages = new core_1.Messages('@salesforce/source-deploy-retrieve', 'sdr', new Map([["md_request_fail", "Metadata API request failed: %s"], ["error_convert_invalid_format", "Invalid conversion format '%s'"], ["error_could_not_infer_type", "%s: Could not infer a metadata type"], ["error_unexpected_child_type", "Unexpected child metadata [%s] found for parent type [%s]"], ["noParent", "Could not find parent type for %s (%s)"], ["error_expected_source_files", "%s: Expected source files for type '%s'"], ["error_failed_convert", "Component conversion failed: %s"], ["error_merge_metadata_target_unsupported", "Merge convert for metadata target format currently unsupported"], ["error_missing_adapter", "Missing adapter '%s' for metadata type '%s'"], ["error_missing_transformer", "Missing transformer '%s' for metadata type '%s'"], ["error_missing_type_definition", "Missing metadata type definition in registry for id '%s'."], ["error_missing_child_type_definition", "Type %s does not have a child type definition %s."], ["noChildTypes", "No child types found in registry for %s (reading %s at %s)"], ["error_no_metadata_xml_ignore", "Metadata xml file %s is forceignored but is required for %s."], ["noSourceIgnore", "%s metadata types require source files, but %s is forceignored."], ["noSourceIgnore.actions", "- Metadata types with content are composed of two files: a content file (ie MyApexClass.cls) and a -meta.xml file (i.e MyApexClass.cls-meta.xml). You must include both files in your .forceignore file. Or try appending \u201C\\*\u201D to your existing .forceignore entry.\n\nSee <https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_exclude_source.htm> for examples"], ["error_path_not_found", "%s: File or folder not found"], ["noContentFound", "SourceComponent %s (metadata type = %s) is missing its content file."], ["noContentFound.actions", ["Ensure the content file exists in the expected location.", "If the content file is in your .forceignore file, ensure the meta-xml file is also ignored to completely exclude it."]], ["error_parsing_xml", "SourceComponent %s (metadata type = %s) does not have an associated metadata xml to parse"], ["error_expected_file_path", "%s: path is to a directory, expected a file"], ["error_expected_directory_path", "%s: path is to a file, expected a directory"], ["error_directory_not_found_or_not_directory", "%s: path is not a directory"], ["error_no_directory_stream", "%s doesn't support readable streams on directories."], ["error_no_source_to_deploy", "No source-backed components present in the package."], ["error_no_components_to_retrieve", "No components in the package to retrieve."], ["error_static_resource_expected_archive_type", "A StaticResource directory must have a content type of application/zip or application/jar - found %s for %s."], ["error_static_resource_missing_resource_file", "A StaticResource must have an associated .resource file, missing %s.resource-meta.xml"], ["error_no_job_id", "The %s operation is missing a job ID. Initialize an operation with an ID, or start a new job."], ["invalid_xml_parsing", "error parsing %s due to:\\n message: %s\\n line: %s\\n code: %s"], ["zipBufferError", "Zip buffer was not created during conversion"], ["undefinedComponentSet", "Unable to construct a componentSet. Check the logs for more information."], ["replacementsFileNotRead", "The file \"%s\" specified in the \"replacements\" property of sfdx-project.json could not be read."], ["unsupportedBundleType", "Unsupported Bundle Type: %s"], ["filePathGeneratorNoTypeSupport", "Type not supported for filepath generation: %s"], ["missingFolderType", "The registry has %s as is inFolder but it does not have a folderType"], ["tooManyFiles", "Multiple files found for path: %s."], ["cantGetName", "Unable to calculate fullName from path: %s (%s)"], ["missingMetaFileSuffix", "The metadata registry is configured incorrectly for %s. Expected a metaFileSuffix."], ["uniqueIdElementNotInRegistry", "No uniqueIdElement found in registry for %s (reading %s at %s)."], ["uniqueIdElementNotInChild", "The uniqueIdElement %s was not found the child (reading %s at %s)."], ["suggest_type_header", "A metadata type lookup for \"%s\" found the following close matches:"], ["suggest_type_did_you_mean", "-- Did you mean \".%s%s\" instead for the \"%s\" metadata type?"], ["suggest_type_more_suggestions", "Additional suggestions:\nConfirm the file name, extension, and directory names are correct. Validate against the registry at:\n<https://github.com/forcedotcom/source-deploy-retrieve/blob/main/src/registry/metadataRegistry.json>\n\nIf the type is not listed in the registry, check that it has Metadata API support via the Metadata Coverage Report:\n<https://developer.salesforce.com/docs/metadata-coverage>\n\nIf the type is available via Metadata API but not in the registry\n\n- Open an issue <https://github.com/forcedotcom/cli/issues>\n- Add the type via PR. Instructions: <https://github.com/forcedotcom/source-deploy-retrieve/blob/main/contributing/metadata.md>"]]));
/**
 * Resolver for metadata type and component objects.
 *
 * @internal
 */
class MetadataResolver {
    /**
     * @param registry Custom registry data
     * @param tree `TreeContainer` to traverse with
     */
    constructor(registry = new registry_1.RegistryAccess(), tree = new treeContainers_1.NodeFSTreeContainer(), useFsForceIgnore = true) {
        this.registry = registry;
        this.tree = tree;
        this.useFsForceIgnore = useFsForceIgnore;
        this.logger = core_1.Logger.childFromRoot(this.constructor.name);
        this.sourceAdapterFactory = new sourceAdapterFactory_1.SourceAdapterFactory(this.registry, tree);
        this.forceIgnoredPaths = new Set();
    }
    /**
     * Get the metadata component(s) from a file path.
     *
     * @param fsPath File path to metadata or directory
     * @param inclusiveFilter Set to filter which components are resolved
     */
    getComponentsFromPath(fsPath, inclusiveFilter) {
        if (!this.tree.exists(fsPath)) {
            throw new core_1.SfError(messages.getMessage('error_path_not_found', [fsPath]), 'TypeInferenceError');
        }
        // use the default ignore if we aren't using a real one
        this.forceIgnore = this.useFsForceIgnore ? forceIgnore_1.ForceIgnore.findAndCreate(fsPath) : new forceIgnore_1.ForceIgnore();
        if (this.tree.isDirectory(fsPath) && !this.resolveDirectoryAsComponent(fsPath)) {
            return this.getComponentsFromPathRecursive(fsPath, inclusiveFilter);
        }
        const component = this.resolveComponent(fsPath, true);
        return component ? [component] : [];
    }
    getComponentsFromPathRecursive(dir, inclusiveFilter) {
        const dirQueue = [];
        const components = [];
        const ignore = new Set();
        // don't apply forceignore rules against dirs
        // `forceignore.denies` will pass a relative path to node-ignore, e.g.
        // `path/to/force-app` -> `force-app`, note that there's no trailing slash
        // so node-ignore will treat it as a file.
        if (!this.tree.isDirectory(dir) && this.forceIgnore?.denies(dir)) {
            return components;
        }
        for (const file of this.tree.readDirectory(dir)) {
            const fsPath = (0, node_path_1.join)(dir, file);
            if (ignore.has(fsPath)) {
                continue;
            }
            if (this.tree.isDirectory(fsPath)) {
                if (this.resolveDirectoryAsComponent(fsPath)) {
                    const component = this.resolveComponent(fsPath, true);
                    if (component && (!inclusiveFilter || inclusiveFilter.has(component))) {
                        components.push(component);
                        ignore.add(component.xml);
                    }
                }
                else {
                    dirQueue.push(fsPath);
                }
            }
            else if (this.isMetadata(fsPath)) {
                const component = this.resolveComponent(fsPath, false);
                if (component) {
                    if (!inclusiveFilter || inclusiveFilter.has(component)) {
                        components.push(component);
                        ignore.add(component.content);
                    }
                    else {
                        for (const child of component.getChildren()) {
                            if (inclusiveFilter.has(child)) {
                                components.push(child);
                            }
                        }
                    }
                    // don't traverse further if not in a root type directory. performance optimization
                    // for mixed content types and ensures we don't add duplicates of the component.
                    const typeDir = (0, node_path_1.basename)((0, node_path_1.dirname)(component.type.inFolder ? (0, node_path_1.dirname)(fsPath) : fsPath));
                    if (component.type.strictDirectoryName && typeDir !== component.type.directoryName) {
                        return components;
                    }
                }
            }
        }
        return components.concat(dirQueue.flatMap((d) => this.getComponentsFromPathRecursive(d, inclusiveFilter)));
    }
    resolveComponent(fsPath, isResolvingSource) {
        if (this.forceIgnore?.denies(fsPath)) {
            // don't resolve the component if the path is denied
            this.forceIgnoredPaths.add(fsPath);
            return;
        }
        const type = this.resolveType(fsPath);
        if (type) {
            const adapter = this.sourceAdapterFactory.getAdapter(type, this.forceIgnore);
            // short circuit the component resolution unless this is a resolve for a
            // source path or allowed content-only path, otherwise the adapter
            // knows how to handle it
            const shouldResolve = parseAsRootMetadataXml(fsPath) ||
                isResolvingSource ||
                !this.parseAsContentMetadataXml(fsPath) ||
                !adapter.allowMetadataWithContent();
            return shouldResolve ? adapter.getComponent(fsPath, isResolvingSource) : undefined;
        }
        // Perform some additional checks to see if this is a package manifest
        if (fsPath.endsWith('.xml') && !fsPath.endsWith(common_1.META_XML_SUFFIX)) {
            // If it is named the default package.xml, assume it is a package manifest
            if (fsPath.endsWith('package.xml'))
                return undefined;
            try {
                // If the file contains the string "<Package xmlns", it is a package manifest
                if (this.tree.readFileSync(fsPath).toString().includes('<Package xmlns'))
                    return undefined;
            }
            catch (err) {
                const error = err;
                if (error.message === 'Method not implemented') {
                    // Currently readFileSync is not implemented for zipTreeContainer
                    // Ignoring since this would have been ignored in the past
                    this.logger.warn(`Type could not be inferred for ${fsPath}. It is likely this is a package manifest. Skipping...`);
                    return undefined;
                }
            }
        }
        void core_1.Lifecycle.getInstance().emitTelemetry({
            eventName: 'metadata_resolver_type_inference_error',
            library: 'SDR',
            function: 'resolveComponent',
            path: fsPath,
        });
        // The metadata type could not be inferred
        // Attempt to guess the type and throw an error with actions
        const actions = this.getSuggestionsForUnresolvedTypes(fsPath);
        throw new core_1.SfError(messages.getMessage('error_could_not_infer_type', [fsPath]), 'TypeInferenceError', actions);
    }
    resolveTypeFromStrictFolder(fsPath) {
        const pathParts = fsPath.split(node_path_1.sep);
        // first, filter out types that don't appear in the path
        // then iterate using for/of to allow for early break
        return this.registry
            .getStrictFolderTypes()
            .filter((type) => 
        // the type's directory is in the path, AND
        pathParts.includes(type.directoryName) &&
            // types with folders only have folder components living at the top level.
            // if the fsPath is a folder component, let a future strategy deal with it
            (!type.inFolder || (0, utils_1.parentName)(fsPath) !== type.directoryName))
            .find((type) => 
        // any of the following 3 options is considered a good match
        // mixedContent and bundles don't have a suffix to match
        (typeof type.strategies?.adapter === 'string' &&
            ['mixedContent', 'bundle'].includes(type.strategies.adapter)) ||
            // the file suffix (in source or mdapi format) matches the type suffix we think it is
            (type.suffix && [type.suffix, `${type.suffix}${common_1.META_XML_SUFFIX}`].some((s) => fsPath.endsWith(s))) ||
            // the type has children and the file suffix (in source format) matches a child type suffix of the type we think it is
            (type.children?.types &&
                Object.values(type.children?.types)
                    .map((childType) => `${childType.suffix}${common_1.META_XML_SUFFIX}`)
                    .some((s) => fsPath.endsWith(s))));
    }
    resolveType(fsPath) {
        // attempt 1 - check if the file is part of a component that requires a strict type folder
        let resolvedType = this.resolveTypeFromStrictFolder(fsPath);
        // attempt 2 - check if it's a metadata xml file
        if (!resolvedType) {
            const parsedMetaXml = (0, utils_1.parseMetadataXml)(fsPath);
            if (parsedMetaXml?.suffix) {
                resolvedType = this.registry.getTypeBySuffix(parsedMetaXml.suffix);
            }
        }
        // attempt 2.5 - test for a folder style xml file
        if (!resolvedType) {
            const metadataFolder = this.parseAsFolderMetadataXml(fsPath);
            if (metadataFolder) {
                // multiple matching directories may exist - folder components are not 'inFolder'
                resolvedType = this.registry.findType((type) => type.directoryName === metadataFolder && !type.inFolder);
            }
        }
        // attempt 3 - try treating the file extension name as a suffix
        if (!resolvedType) {
            resolvedType = this.registry.getTypeBySuffix((0, utils_1.extName)(fsPath));
            // Metadata types with `strictDirectoryName` should have been caught in "attempt 1".
            // If the metadata returned from this lookup has a `strictDirectoryName`, something is wrong.
            // It is likely that the metadata file is misspelled or has the wrong suffix.
            // A common occurrence is that a misspelled metadata file will fall back to
            // `EmailServicesFunction` because that is the default for the `.xml` suffix
            if (resolvedType?.strictDirectoryName === true) {
                resolvedType = undefined;
            }
        }
        // attempt 4 - try treating the content as metadata
        if (!resolvedType) {
            const metadata = this.parseAsMetadata(fsPath);
            if (metadata) {
                resolvedType = this.registry.getTypeByName(metadata);
            }
        }
        return resolvedType;
    }
    /**
     * Attempt to find similar types for types that could not be inferred
     * To be used after executing the resolveType() method
     *
     * @param fsPath
     * @returns an array of suggestions
     */
    getSuggestionsForUnresolvedTypes(fsPath) {
        const parsedMetaXml = (0, utils_1.parseMetadataXml)(fsPath);
        const metaSuffix = parsedMetaXml?.suffix;
        // Finds close matches for meta suffixes
        // Examples: https://regex101.com/r/vbRjwy/1
        const closeMetaSuffix = new RegExp(/.+\.([^.-]+)(?:-.*)?\.xml/).exec((0, node_path_1.basename)(fsPath));
        let guesses;
        if (metaSuffix) {
            guesses = this.registry.guessTypeBySuffix(metaSuffix);
        }
        else if (!metaSuffix && closeMetaSuffix) {
            guesses = this.registry.guessTypeBySuffix(closeMetaSuffix[1]);
        }
        else {
            guesses = this.registry.guessTypeBySuffix((0, utils_1.extName)(fsPath));
        }
        // If guesses were found, format an array of strings to be passed to SfError's actions
        return guesses && guesses.length > 0
            ? [
                messages.getMessage('suggest_type_header', [(0, node_path_1.basename)(fsPath)]),
                ...guesses.map((guess) => messages.getMessage('suggest_type_did_you_mean', [
                    guess.suffixGuess,
                    metaSuffix || closeMetaSuffix ? '-meta.xml' : '',
                    guess.metadataTypeGuess.name,
                ])),
                '',
                messages.getMessage('suggest_type_more_suggestions'),
            ]
            : [];
    }
    /**
     * Whether or not a directory that represents a single component should be resolved as one,
     * or if it should be walked for additional components.
     *
     * If a type can be determined from a directory path, and the end part of the path isn't
     * the directoryName of the type itself, infer the path is part of a mixedContent component
     *
     * @param dirPath Path to a directory
     */
    resolveDirectoryAsComponent(dirPath) {
        let shouldResolve = true;
        const type = this.resolveType(dirPath);
        if (type) {
            const { directoryName, inFolder } = type;
            const parts = dirPath.split(node_path_1.sep);
            const folderOffset = inFolder ? 2 : 1;
            const typeDirectoryIndex = parts.lastIndexOf(directoryName);
            if (typeDirectoryIndex === -1 ||
                parts.length - folderOffset <= typeDirectoryIndex ||
                // ex: /lwc/folder/lwc/cmp
                this.tree.readDirectory(dirPath).includes(type.directoryName) ||
                // types with children may want to resolve them individually
                type.children) {
                shouldResolve = false;
            }
        }
        else {
            shouldResolve = false;
        }
        return shouldResolve;
    }
    /**
     * Any file with a registered suffix is potentially a content metadata file.
     *
     * @param fsPath File path of a potential content metadata file
     */
    parseAsContentMetadataXml(fsPath) {
        return !!this.registry.getTypeBySuffix((0, utils_1.extName)(fsPath));
    }
    // Get the array of directoryNames for types that have folderContentType
    getFolderContentTypeDirNames() {
        if (!this.folderContentTypeDirNames) {
            this.folderContentTypeDirNames = this.registry.getFolderContentTypes().map((t) => t.directoryName);
        }
        return this.folderContentTypeDirNames;
    }
    /**
     * Identify metadata xml for a folder component:
     * .../email/TestFolder-meta.xml
     * .../reports/foo/bar-meta.xml
     *
     * Do not match this pattern:
     * .../tabs/TestFolder.tab-meta.xml
     */
    parseAsFolderMetadataXml(fsPath) {
        let folderName;
        const match = new RegExp(/(.+)-meta\.xml/).exec((0, node_path_1.basename)(fsPath));
        if (match && !match[1].includes('.')) {
            const parts = fsPath.split(node_path_1.sep);
            if (parts.length > 1) {
                const folderContentTypesDirs = this.getFolderContentTypeDirNames();
                // check if the path contains a folder content name as a directory
                // e.g., `/reports/` and if it does return that folder name.
                folderContentTypesDirs.some((dirName) => {
                    if (fsPath.includes(`${node_path_1.sep}${dirName}${node_path_1.sep}`)) {
                        folderName = dirName;
                    }
                });
            }
        }
        return folderName;
    }
    /**
     * If this file should be considered as a metadata file then return the metadata type
     */
    parseAsMetadata(fsPath) {
        if (this.tree.isDirectory(fsPath)) {
            return;
        }
        return ['DigitalExperience', 'ExperiencePropertyTypeBundle']
            .map((type) => this.registry.getTypeByName(type))
            .find((type) => fsPath.split(node_path_1.sep).includes(type.directoryName))?.name;
    }
    isMetadata(fsPath) {
        return (!!(0, utils_1.parseMetadataXml)(fsPath) ||
            this.parseAsContentMetadataXml(fsPath) ||
            !!this.parseAsFolderMetadataXml(fsPath) ||
            !!this.parseAsMetadata(fsPath));
    }
}
exports.MetadataResolver = MetadataResolver;
/**
 * Any metadata xml file (-meta.xml) is potentially a root metadata file.
 *
 * @param fsPath File path of a potential metadata xml file
 */
const parseAsRootMetadataXml = (fsPath) => Boolean((0, utils_1.parseMetadataXml)(fsPath));
//# sourceMappingURL=metadataResolver.js.map