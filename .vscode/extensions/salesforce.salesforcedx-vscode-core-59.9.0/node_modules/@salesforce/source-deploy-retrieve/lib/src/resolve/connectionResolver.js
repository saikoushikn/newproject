"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectionResolver = void 0;
const ts_retry_promise_1 = require("ts-retry-promise");
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const ts_types_1 = require("@salesforce/ts-types");
const registry_1 = require("../registry");
const standardvalueset_1 = require("../registry/standardvalueset");
const utils_1 = require("../utils");
const messages = new core_1.Messages('@salesforce/source-deploy-retrieve', 'sdr', new Map([["md_request_fail", "Metadata API request failed: %s"], ["error_convert_invalid_format", "Invalid conversion format '%s'"], ["error_could_not_infer_type", "%s: Could not infer a metadata type"], ["error_unexpected_child_type", "Unexpected child metadata [%s] found for parent type [%s]"], ["noParent", "Could not find parent type for %s (%s)"], ["error_expected_source_files", "%s: Expected source files for type '%s'"], ["error_failed_convert", "Component conversion failed: %s"], ["error_merge_metadata_target_unsupported", "Merge convert for metadata target format currently unsupported"], ["error_missing_adapter", "Missing adapter '%s' for metadata type '%s'"], ["error_missing_transformer", "Missing transformer '%s' for metadata type '%s'"], ["error_missing_type_definition", "Missing metadata type definition in registry for id '%s'."], ["error_missing_child_type_definition", "Type %s does not have a child type definition %s."], ["noChildTypes", "No child types found in registry for %s (reading %s at %s)"], ["error_no_metadata_xml_ignore", "Metadata xml file %s is forceignored but is required for %s."], ["noSourceIgnore", "%s metadata types require source files, but %s is forceignored."], ["noSourceIgnore.actions", "- Metadata types with content are composed of two files: a content file (ie MyApexClass.cls) and a -meta.xml file (i.e MyApexClass.cls-meta.xml). You must include both files in your .forceignore file. Or try appending \u201C\\*\u201D to your existing .forceignore entry.\n\nSee <https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_exclude_source.htm> for examples"], ["error_path_not_found", "%s: File or folder not found"], ["noContentFound", "SourceComponent %s (metadata type = %s) is missing its content file."], ["noContentFound.actions", ["Ensure the content file exists in the expected location.", "If the content file is in your .forceignore file, ensure the meta-xml file is also ignored to completely exclude it."]], ["error_parsing_xml", "SourceComponent %s (metadata type = %s) does not have an associated metadata xml to parse"], ["error_expected_file_path", "%s: path is to a directory, expected a file"], ["error_expected_directory_path", "%s: path is to a file, expected a directory"], ["error_directory_not_found_or_not_directory", "%s: path is not a directory"], ["error_no_directory_stream", "%s doesn't support readable streams on directories."], ["error_no_source_to_deploy", "No source-backed components present in the package."], ["error_no_components_to_retrieve", "No components in the package to retrieve."], ["error_static_resource_expected_archive_type", "A StaticResource directory must have a content type of application/zip or application/jar - found %s for %s."], ["error_static_resource_missing_resource_file", "A StaticResource must have an associated .resource file, missing %s.resource-meta.xml"], ["error_no_job_id", "The %s operation is missing a job ID. Initialize an operation with an ID, or start a new job."], ["invalid_xml_parsing", "error parsing %s due to:\\n message: %s\\n line: %s\\n code: %s"], ["zipBufferError", "Zip buffer was not created during conversion"], ["undefinedComponentSet", "Unable to construct a componentSet. Check the logs for more information."], ["replacementsFileNotRead", "The file \"%s\" specified in the \"replacements\" property of sfdx-project.json could not be read."], ["unsupportedBundleType", "Unsupported Bundle Type: %s"], ["filePathGeneratorNoTypeSupport", "Type not supported for filepath generation: %s"], ["missingFolderType", "The registry has %s as is inFolder but it does not have a folderType"], ["tooManyFiles", "Multiple files found for path: %s."], ["cantGetName", "Unable to calculate fullName from path: %s (%s)"], ["missingMetaFileSuffix", "The metadata registry is configured incorrectly for %s. Expected a metaFileSuffix."], ["uniqueIdElementNotInRegistry", "No uniqueIdElement found in registry for %s (reading %s at %s)."], ["uniqueIdElementNotInChild", "The uniqueIdElement %s was not found the child (reading %s at %s)."], ["suggest_type_header", "A metadata type lookup for \"%s\" found the following close matches:"], ["suggest_type_did_you_mean", "-- Did you mean \".%s%s\" instead for the \"%s\" metadata type?"], ["suggest_type_more_suggestions", "Additional suggestions:\nConfirm the file name, extension, and directory names are correct. Validate against the registry at:\n<https://github.com/forcedotcom/source-deploy-retrieve/blob/main/src/registry/metadataRegistry.json>\n\nIf the type is not listed in the registry, check that it has Metadata API support via the Metadata Coverage Report:\n<https://developer.salesforce.com/docs/metadata-coverage>\n\nIf the type is available via Metadata API but not in the registry\n\n- Open an issue <https://github.com/forcedotcom/cli/issues>\n- Add the type via PR. Instructions: <https://github.com/forcedotcom/source-deploy-retrieve/blob/main/contributing/metadata.md>"]]));
/**
 * Resolve MetadataComponents from an org connection
 */
class ConnectionResolver {
    constructor(connection, registry = new registry_1.RegistryAccess()) {
        this.connection = connection;
        this.registry = registry;
        this.logger = core_1.Logger.childFromRoot(this.constructor.name);
    }
    async resolve(componentFilter = (component) => (0, ts_types_1.isPlainObject)(component)) {
        const Aggregator = [];
        const childrenPromises = [];
        const componentTypes = new Set();
        const lifecycle = core_1.Lifecycle.getInstance();
        const componentPromises = [];
        for (const type of Object.values(registry_1.registry.types)) {
            componentPromises.push(this.listMembers({ type: type.name }));
        }
        (await Promise.all(componentPromises)).map(async (componentResult) => {
            for (const component of componentResult) {
                let componentType;
                if (typeof component.type === 'string' && component.type.length) {
                    componentType = this.registry.getTypeByName(component.type);
                }
                else if (typeof component.fileName === 'string' && component.fileName.length) {
                    // fix { type: { "$": { "xsi:nil": "true" } } }
                    componentType = (0, ts_types_1.ensurePlainObject)(this.registry.getTypeBySuffix((0, utils_1.extName)(component.fileName)), `No type found for ${component.fileName} when matching by suffix.  Check the file extension.`);
                    component.type = componentType.name;
                }
                else if (component.type === undefined && component.fileName === undefined) {
                    // has no type and has no filename!  Warn and skip that component.
                    // eslint-disable-next-line no-await-in-loop
                    await Promise.all([
                        lifecycle.emitWarning(messages.getMessage('error_could_not_infer_type', [component.fullName])),
                        lifecycle.emitTelemetry({ TypeInferenceError: component, from: 'ConnectionResolver' }),
                    ]);
                    continue;
                }
                else {
                    // it DOES have all the important info but we couldn't resolve it.
                    // has no type and has no filename!
                    throw new core_1.SfError(messages.getMessage('error_could_not_infer_type', [component.fullName]), 'TypeInferenceError', [messages.getMessage('suggest_type_more_suggestions')]);
                }
                Aggregator.push(component);
                componentTypes.add(componentType);
                const folderContentType = componentType.folderContentType;
                if (folderContentType) {
                    childrenPromises.push(this.listMembers({
                        type: this.registry.getTypeByName(folderContentType).name,
                        folder: component.fullName,
                    }));
                }
            }
        });
        for (const componentType of componentTypes) {
            const childTypes = componentType.children?.types;
            if (childTypes) {
                Object.values(childTypes).map((childType) => {
                    childrenPromises.push(this.listMembers({ type: childType.name }));
                });
            }
        }
        for await (const childrenResult of childrenPromises) {
            Aggregator.push(...childrenResult);
        }
        return {
            components: Aggregator.filter(componentFilter).map((component) => ({
                fullName: (0, ts_types_1.ensureString)(component.fullName, `Component fullName was not set for ${component.fileName}`),
                type: this.registry.getTypeByName((0, ts_types_1.ensureString)(component.type, `Component type was not set for ${component.fullName} (${component.fileName})`)),
            })),
            apiVersion: this.connection.getApiVersion(),
        };
    }
    async listMembers(query) {
        let members;
        const pollingOptions = {
            frequency: kit_1.Duration.milliseconds(1000),
            timeout: kit_1.Duration.minutes(3),
            poll: async () => {
                const res = (0, kit_1.ensureArray)(await this.connection.metadata.list(query));
                return { completed: true, payload: res };
            },
        };
        const pollingClient = await core_1.PollingClient.create(pollingOptions);
        try {
            members = await pollingClient.subscribe();
        }
        catch (error) {
            // throw error if PollingClient timed out.
            if (error instanceof ts_retry_promise_1.NotRetryableError) {
                throw ts_retry_promise_1.NotRetryableError;
            }
            this.logger.debug(error.message);
            members = [];
        }
        // if the Metadata Type doesn't return a correct fileName then help it out
        for (const m of members) {
            if (typeof m.fileName == 'object') {
                const t = this.registry.getTypeByName(query.type);
                m.fileName = `${t.directoryName}/${m.fullName}.${t.suffix}`;
            }
        }
        // Workaround because metadata.list({ type: 'StandardValueSet' }) returns []
        if (query.type === registry_1.registry.types.standardvalueset.name && members.length === 0) {
            const standardValueSetPromises = standardvalueset_1.standardValueSet.fullnames.map(async (standardValueSetFullName) => {
                try {
                    // The 'singleRecordQuery' method was having connection errors, using `retry` resolves this
                    // Note that this type of connection retry logic may someday be added to jsforce v2
                    // Once that happens this logic could be reverted
                    const standardValueSetRecord = await (0, ts_retry_promise_1.retry)(async () => {
                        try {
                            return await this.connection.singleRecordQuery(`SELECT Id, MasterLabel, Metadata FROM StandardValueSet WHERE MasterLabel = '${standardValueSetFullName}'`, { tooling: true });
                        }
                        catch (err) {
                            // We exit the retry loop with `NotRetryableError` if we get an (expected) unsupported metadata type error
                            const error = err;
                            if (error.message.includes('either inaccessible or not supported in Metadata API')) {
                                this.logger.debug('Expected error:', error.message);
                                throw new ts_retry_promise_1.NotRetryableError(error.message);
                            }
                            // Otherwise throw the err so we can retry again
                            throw err;
                        }
                    });
                    return (standardValueSetRecord.Metadata.standardValue.length && {
                        fullName: standardValueSetRecord.MasterLabel,
                        fileName: `${registry_1.registry.types.standardvalueset.directoryName}/${standardValueSetRecord.MasterLabel}.${registry_1.registry.types.standardvalueset.suffix}`,
                        type: registry_1.registry.types.standardvalueset.name,
                        createdById: '',
                        createdByName: '',
                        createdDate: '',
                        id: '',
                        lastModifiedById: '',
                        lastModifiedByName: '',
                        lastModifiedDate: '',
                    });
                }
                catch (err) {
                    // error.message here will be overwritten by 'ts-retry-promise'
                    // Example error.message from the library: "All retries failed" or "Met not retryable error"
                    // 'ts-retry-promise' exposes the actual error on `error.lastError`
                    const error = err;
                    if (error.lastError?.message) {
                        this.logger.debug(error.lastError.message);
                    }
                }
            });
            for await (const standardValueSetResult of standardValueSetPromises) {
                if (standardValueSetResult) {
                    members.push(standardValueSetResult);
                }
            }
        }
        return members;
    }
}
exports.ConnectionResolver = ConnectionResolver;
//# sourceMappingURL=connectionResolver.js.map