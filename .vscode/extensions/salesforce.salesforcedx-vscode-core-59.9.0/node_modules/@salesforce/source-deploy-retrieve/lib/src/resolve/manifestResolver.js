"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ManifestResolver = void 0;
const fast_xml_parser_1 = require("fast-xml-parser");
const kit_1 = require("@salesforce/kit");
const core_1 = require("@salesforce/core");
const registry_1 = require("../registry");
const treeContainers_1 = require("./treeContainers");
/**
 * Resolve MetadataComponents from a manifest file (package.xml)
 */
class ManifestResolver {
    constructor(tree = new treeContainers_1.NodeFSTreeContainer(), registry = new registry_1.RegistryAccess()) {
        this.tree = tree;
        this.registry = registry;
    }
    async resolve(manifestPath) {
        const components = [];
        const file = (await this.tree.readFile(manifestPath)).toString();
        const validateResult = fast_xml_parser_1.XMLValidator.validate(file);
        if (validateResult !== true) {
            const error = new core_1.SfError(`Invalid manifest file: ${manifestPath}.  ${validateResult.err.code}: ${validateResult.err.msg} (Line ${validateResult.err.line} Column ${validateResult.err.col})`, 'InvalidManifest');
            error.setData(validateResult.err);
            throw error;
        }
        const parser = new fast_xml_parser_1.XMLParser({
            stopNodes: ['version'],
            // In order to preserve the .0 on the apiVersion skip parsing it
            numberParseOptions: { leadingZeros: false, hex: false, skipLike: /\.0$/ },
        });
        const parsedManifest = parser.parse(file).Package;
        const packageTypeMembers = (0, kit_1.ensureArray)(parsedManifest.types);
        const apiVersion = parsedManifest.version;
        for (const typeMembers of packageTypeMembers) {
            let typeName = typeMembers.name;
            // protect against empty/invalid typeMember definitions in the manifest
            if (typeof typeName !== 'string' || typeName.length === 0) {
                if (typeof typeName === 'object') {
                    typeName = JSON.stringify(typeName);
                }
                const err = new Error(`Invalid types definition in manifest file: ${manifestPath}\nFound: "${typeName ?? ''}"`);
                err.name = 'InvalidManifest';
                throw err;
            }
            const type = this.registry.getTypeByName(typeName);
            const parentType = type.folderType ? this.registry.getTypeByName(type.folderType) : undefined;
            const members = (0, kit_1.ensureArray)(typeMembers.members);
            for (const fullName of members) {
                let mdType = type;
                if (parentType && isMemberNestedInFolder(fullName, type, parentType, members)) {
                    mdType = parentType;
                }
                components.push({ fullName, type: mdType });
            }
        }
        return { components, apiVersion };
    }
}
exports.ManifestResolver = ManifestResolver;
// Use the folderType instead of the type from the manifest when:
//  1. InFolder types: (report, dashboard, emailTemplate, document)
//    1a. type.inFolder === true (from metadataRegistry.json) AND
//    1b. The fullName doesn't contain a forward slash character AND
//    1c. The fullName with a slash appended is contained in another member entry
// OR
//  2. Non-InFolder, folder types: (territory2, territory2Model, territory2Type, territory2Rule)
//    2a. type.inFolder !== true (from metadataRegistry.json) AND
//    2b. type.folderType has a value (from metadataRegistry.json) AND
//    2c. This type's parent type has a folderType that doesn't match its ID.
const isMemberNestedInFolder = (fullName, type, parentType, members) => {
    // Quick short-circuit for non-folderTypes
    if (!type.folderType) {
        return false;
    }
    const isInFolderType = type.inFolder;
    const isNestedInFolder = !fullName.includes('/') || members.some((m) => m.includes(`${fullName}/`));
    const isNonMatchingFolder = parentType && parentType.folderType !== parentType.id;
    return (isInFolderType && isNestedInFolder) || (!isInFolderType && isNonMatchingFolder);
};
//# sourceMappingURL=manifestResolver.js.map