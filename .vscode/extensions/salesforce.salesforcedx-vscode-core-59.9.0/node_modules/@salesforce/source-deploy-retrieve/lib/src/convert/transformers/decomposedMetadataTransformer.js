"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DecomposedMetadataTransformer = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const node_path_1 = require("node:path");
const kit_1 = require("@salesforce/kit");
const core_1 = require("@salesforce/core");
const streams_1 = require("../streams");
const common_1 = require("../../common");
const collections_1 = require("../../collections");
const baseMetadataTransformer_1 = require("./baseMetadataTransformer");
const messages = new core_1.Messages('@salesforce/source-deploy-retrieve', 'sdr', new Map([["md_request_fail", "Metadata API request failed: %s"], ["error_convert_invalid_format", "Invalid conversion format '%s'"], ["error_could_not_infer_type", "%s: Could not infer a metadata type"], ["error_unexpected_child_type", "Unexpected child metadata [%s] found for parent type [%s]"], ["noParent", "Could not find parent type for %s (%s)"], ["error_expected_source_files", "%s: Expected source files for type '%s'"], ["error_failed_convert", "Component conversion failed: %s"], ["error_merge_metadata_target_unsupported", "Merge convert for metadata target format currently unsupported"], ["error_missing_adapter", "Missing adapter '%s' for metadata type '%s'"], ["error_missing_transformer", "Missing transformer '%s' for metadata type '%s'"], ["error_missing_type_definition", "Missing metadata type definition in registry for id '%s'."], ["error_missing_child_type_definition", "Type %s does not have a child type definition %s."], ["noChildTypes", "No child types found in registry for %s (reading %s at %s)"], ["error_no_metadata_xml_ignore", "Metadata xml file %s is forceignored but is required for %s."], ["noSourceIgnore", "%s metadata types require source files, but %s is forceignored."], ["noSourceIgnore.actions", "- Metadata types with content are composed of two files: a content file (ie MyApexClass.cls) and a -meta.xml file (i.e MyApexClass.cls-meta.xml). You must include both files in your .forceignore file. Or try appending \u201C\\*\u201D to your existing .forceignore entry.\n\nSee <https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_exclude_source.htm> for examples"], ["error_path_not_found", "%s: File or folder not found"], ["noContentFound", "SourceComponent %s (metadata type = %s) is missing its content file."], ["noContentFound.actions", ["Ensure the content file exists in the expected location.", "If the content file is in your .forceignore file, ensure the meta-xml file is also ignored to completely exclude it."]], ["error_parsing_xml", "SourceComponent %s (metadata type = %s) does not have an associated metadata xml to parse"], ["error_expected_file_path", "%s: path is to a directory, expected a file"], ["error_expected_directory_path", "%s: path is to a file, expected a directory"], ["error_directory_not_found_or_not_directory", "%s: path is not a directory"], ["error_no_directory_stream", "%s doesn't support readable streams on directories."], ["error_no_source_to_deploy", "No source-backed components present in the package."], ["error_no_components_to_retrieve", "No components in the package to retrieve."], ["error_static_resource_expected_archive_type", "A StaticResource directory must have a content type of application/zip or application/jar - found %s for %s."], ["error_static_resource_missing_resource_file", "A StaticResource must have an associated .resource file, missing %s.resource-meta.xml"], ["error_no_job_id", "The %s operation is missing a job ID. Initialize an operation with an ID, or start a new job."], ["invalid_xml_parsing", "error parsing %s due to:\\n message: %s\\n line: %s\\n code: %s"], ["zipBufferError", "Zip buffer was not created during conversion"], ["undefinedComponentSet", "Unable to construct a componentSet. Check the logs for more information."], ["replacementsFileNotRead", "The file \"%s\" specified in the \"replacements\" property of sfdx-project.json could not be read."], ["unsupportedBundleType", "Unsupported Bundle Type: %s"], ["filePathGeneratorNoTypeSupport", "Type not supported for filepath generation: %s"], ["missingFolderType", "The registry has %s as is inFolder but it does not have a folderType"], ["tooManyFiles", "Multiple files found for path: %s."], ["cantGetName", "Unable to calculate fullName from path: %s (%s)"], ["missingMetaFileSuffix", "The metadata registry is configured incorrectly for %s. Expected a metaFileSuffix."], ["uniqueIdElementNotInRegistry", "No uniqueIdElement found in registry for %s (reading %s at %s)."], ["uniqueIdElementNotInChild", "The uniqueIdElement %s was not found the child (reading %s at %s)."], ["suggest_type_header", "A metadata type lookup for \"%s\" found the following close matches:"], ["suggest_type_did_you_mean", "-- Did you mean \".%s%s\" instead for the \"%s\" metadata type?"], ["suggest_type_more_suggestions", "Additional suggestions:\nConfirm the file name, extension, and directory names are correct. Validate against the registry at:\n<https://github.com/forcedotcom/source-deploy-retrieve/blob/main/src/registry/metadataRegistry.json>\n\nIf the type is not listed in the registry, check that it has Metadata API support via the Metadata Coverage Report:\n<https://developer.salesforce.com/docs/metadata-coverage>\n\nIf the type is available via Metadata API but not in the registry\n\n- Open an issue <https://github.com/forcedotcom/cli/issues>\n- Add the type via PR. Instructions: <https://github.com/forcedotcom/source-deploy-retrieve/blob/main/contributing/metadata.md>"]]));
class DecomposedMetadataTransformer extends baseMetadataTransformer_1.BaseMetadataTransformer {
    // eslint-disable-next-line @typescript-eslint/require-await
    async toMetadataFormat(component) {
        if (component.parent) {
            const { fullName: parentName } = component.parent;
            const stateForParent = this.context.recomposition.transactionState.get(parentName) ?? {
                component: component.parent,
                children: new collections_1.ComponentSet([], this.registry),
            };
            stateForParent.children?.add(component);
            this.context.recomposition.transactionState.set(parentName, stateForParent);
        }
        else {
            const { fullName } = component;
            const existing = this.context.recomposition.transactionState.get(fullName) ?? {
                component,
                children: new collections_1.ComponentSet([], this.registry),
            };
            (component.getChildren() ?? []).map((child) => {
                existing.children?.add(child);
            });
            this.context.recomposition.transactionState.set(fullName, existing);
        }
        // noop since the finalizer will push the writes to the component writer
        return [];
    }
    // eslint-disable-next-line complexity
    async toSourceFormat(component, mergeWith) {
        const outputFile = mergeWith?.xml ?? getDefaultOutput(component);
        const forceIgnore = component.getForceIgnore();
        // if the whole parent is ignored, we won't worry about decomposing things
        // this can happen if the manifest had a *; all the members will be retrieved.
        if (forceIgnore.denies(outputFile)) {
            return [];
        }
        const writeInfos = [];
        const childrenOfMergeComponent = new collections_1.ComponentSet(mergeWith?.getChildren());
        const { type, fullName: parentFullName } = component;
        let parentXmlObject;
        const composedMetadata = await getComposedMetadataEntries(component);
        for (const [tagKey, tagValue] of composedMetadata) {
            const childTypeId = type.children?.directories?.[tagKey];
            if (childTypeId) {
                const childType = type.children?.types[childTypeId];
                if (!childType) {
                    throw messages.createError('error_missing_child_type_definition', [type.name, childTypeId]);
                }
                const tagValues = (0, kit_1.ensureArray)(tagValue);
                for (const value of tagValues) {
                    const entryName = value.fullName || value.name;
                    const childComponent = {
                        fullName: `${parentFullName}.${entryName}`,
                        type: childType,
                        parent: component,
                    };
                    // only process child types that aren't forceignored
                    if (forceIgnore.accepts(getDefaultOutput(childComponent))) {
                        const source = new streams_1.JsToXml({
                            [childType.name]: Object.assign({ [common_1.XML_NS_KEY]: common_1.XML_NS_URL }, value),
                        });
                        /*
                         composedMetadata is a representation of the parent's xml
                         if there is no CustomObjectTranslation in the org, the composedMetadata will be 2 entries
                         the xml declaration, and a fields attribute, which points to the child CustomObjectFieldTranslation
                         because CustomObjectFieldTranslation is the only metadata type with 'requiresParent' = true we can
                         calculate if a CustomObjectTranslation was retrieved from the org (composedMetadata.length > 2), or,
                         if we'll have to write an empty CustomObjectTranslation file (composedMetadata.length <=2).
                         CustomObjectFieldTranslations are only addressable through their parent, and require a
                         CustomObjectTranslation file to be present
                         */
                        if (childType.unaddressableWithoutParent && composedMetadata.length <= 2) {
                            parentXmlObject = {
                                [component.type.name]: '',
                            };
                            this.setDecomposedState(childComponent, {
                                foundMerge: false,
                                writeInfo: {
                                    source: new streams_1.JsToXml(parentXmlObject),
                                    output: getDefaultOutput(component),
                                },
                            });
                        }
                        // if there's nothing to merge with, push write operation now to default location
                        if (!mergeWith) {
                            writeInfos.push({
                                source,
                                output: getDefaultOutput(childComponent),
                            });
                        }
                        // if the merge parent has a child that can be merged with, push write
                        // operation now and mark it as merged in the state
                        else if (childrenOfMergeComponent.has(childComponent)) {
                            const mergeChild = childrenOfMergeComponent.getSourceComponents(childComponent).first();
                            if (!mergeChild?.xml) {
                                throw messages.createError('error_parsing_xml', [childComponent.fullName, childComponent.type.name]);
                            }
                            writeInfos.push({
                                source,
                                output: mergeChild.xml,
                            });
                            this.setDecomposedState(childComponent, { foundMerge: true });
                        }
                        // If we have a parent and the child is unaddressable without the parent, keep them
                        // together on the file system, meaning a new child will not be written to the default dir.
                        else if (childType.unaddressableWithoutParent) {
                            // get output path from parent
                            const childFileName = `${entryName}.${childComponent.type.suffix}${common_1.META_XML_SUFFIX}`;
                            const output = (0, node_path_1.join)((0, node_path_1.dirname)(mergeWith.xml), childFileName);
                            writeInfos.push({ source, output });
                        }
                        // if no child component is found to merge with yet, mark it as so in
                        // the state
                        else if (!this.getDecomposedState(childComponent)?.foundMerge) {
                            this.setDecomposedState(childComponent, {
                                foundMerge: false,
                                writeInfo: {
                                    source,
                                    output: getDefaultOutput(childComponent),
                                },
                            });
                        }
                    }
                }
            }
            else if (tagKey !== common_1.XML_NS_KEY) {
                // tag entry isn't a child type, so add it to the parent xml
                if (!parentXmlObject) {
                    parentXmlObject = { [type.name]: { [common_1.XML_NS_KEY]: common_1.XML_NS_URL } };
                }
                const tagGroup = parentXmlObject[type.name];
                tagGroup[tagKey] = tagValue;
            }
        }
        const parentState = this.getDecomposedState(component);
        if (!parentState && parentXmlObject) {
            const parentSource = new streams_1.JsToXml(parentXmlObject);
            if (!mergeWith) {
                writeInfos.push({
                    source: parentSource,
                    output: outputFile,
                });
            }
            else if (mergeWith.xml) {
                writeInfos.push({
                    source: parentSource,
                    output: outputFile,
                });
                this.setDecomposedState(component, { foundMerge: true });
            }
            else {
                this.setDecomposedState(component, {
                    foundMerge: false,
                    writeInfo: {
                        source: parentSource,
                        output: outputFile,
                    },
                });
            }
        }
        return writeInfos;
    }
    /**
     * Helper for setting the decomposed transaction state
     *
     * @param forComponent
     * @param props
     */
    setDecomposedState(forComponent, props = {}) {
        const key = `${forComponent.type.name}#${forComponent.fullName}`;
        const withOrigin = Object.assign({ origin: forComponent.parent ?? forComponent }, props);
        this.context.decomposition.transactionState.set(key, {
            ...(this.context.decomposition.transactionState.get(key) ?? {}),
            ...withOrigin,
        });
    }
    getDecomposedState(forComponent) {
        const key = `${forComponent.type.name}#${forComponent.fullName}`;
        return this.context.decomposition.transactionState.get(key);
    }
}
exports.DecomposedMetadataTransformer = DecomposedMetadataTransformer;
const getComposedMetadataEntries = async (component) => {
    const composedMetadata = (await component.parseXml())[component.type.name];
    // composedMetadata might be undefined if you call toSourceFormat() from a non-source-backed Component
    return composedMetadata ? Object.entries(composedMetadata) : [];
};
const getDefaultOutput = (component) => {
    const { parent, fullName, type } = component;
    const [baseName, childName] = fullName.split('.');
    const baseComponent = (parent ?? component);
    let output = `${childName ?? baseName}.${component.type.suffix}${common_1.META_XML_SUFFIX}`;
    if (parent?.type.strategies?.decomposition === "folderPerType" /* DecompositionStrategy.FolderPerType */) {
        output = (0, node_path_1.join)(type.directoryName, output);
    }
    return (0, node_path_1.join)(baseComponent.getPackageRelativePath(baseName, 'source'), output);
};
//# sourceMappingURL=decomposedMetadataTransformer.js.map